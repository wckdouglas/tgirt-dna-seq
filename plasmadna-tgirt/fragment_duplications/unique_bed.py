#!/usr/bin/env python

import numpy as np
from scipy.spatial.distance import hamming
from itertools import combinations
from functools import partial
from collections import defaultdict
from networkx import Graph, connected_components
import sys
import argparse


def get_opt():
    help_message = 'Demultiplexing UMI bed file with the follwing columns:\n'+\
            '1. chrom name\n2. start\n3. end\n4. strand\n5. collapsed barcodes delim by ","\n'+\
            'This file can be generated by the command: \n'+\
            '   bedtools merge -i $BED_FILE -s -c $I -o collapse -delim ","  \n'+\
            'with barcode at column $I of a $BED_FILE \n'+\
            'The program internally used hamming distance matrix of the '+\
            'barcodes to generate connected network and cluster them'
    parser = argparse.ArgumentParser(description=help_message)
    parser.add_argument('-i','--infile',
                        help ='input bedfile, can be "-" or "/dev/stdin" for stdin (default: -)',
                        default = '-')
    parser.add_argument('-t','--threshold',
                        help='How many error between barcodes can be tolerated? (default = 1)',
                        type=int, default = 1)
    args = parser.parse_args()
    return args


def hamming_barcode(barcode_pair, threshold):
    a, b = barcode_pair
    assert len(a) == len(b), 'Wrong barcode extraction'
    is_path =  1 if hamming(list(a), list(b)) * len(a) <= threshold else 0
    return (a,b,is_path)


def make_graph(barcode_array):
    G = Graph()
    for pair in barcode_array:
        if pair[2] == 1:
            G.add_edge(pair[0],pair[1])
        else:
            G.add_node(pair[0])
            G.add_node(pair[1])
    return G


def unique_barcode_from_graph(graph):
    unique_barcode = []
    for subgraph in connected_components(graph):
        subgraph = list(subgraph)
        subgraph_size = len(subgraph)
        if subgraph_size == 1:
            unique_barcode.append(subgraph[0])
        else:
            barcode = subgraph[0] + '_' + str(subgraph_size) + '_members'
            unique_barcode.append(barcode)
    return unique_barcode

def demultiplex(barcodes, threshold):
    comparison = combinations(set(barcodes),r=2)
    barcode_array = [hamming_barcode(barcode_pair, threshold) for barcode_pair in comparison]
    graph = make_graph(barcode_array)
    unique_barcode =  unique_barcode_from_graph(graph)
    #print 'In: %i, out: %i' %(len(barcodes), len(unique_barcode))
    return unique_barcode


def make_line(chrom, start, end, strand, barcode):
    length = long(end) - long(start)
    template = '{chrom}\t{start}\t{end}\t{barcode}\t{length}\t{strand}' \
                .format(chrom = chrom,
                        start = start,
                        end = end,
                        barcode = barcode,
                        length = length,
                        strand= strand)
    return template


def file_processing(file_handle, threshold):
    for line in file_handle:
        line = line.rstrip('\n')
        fields = line.split('\t')
        barcodes = fields[-1]
        template = partial(make_line, fields[0], fields[1], fields[2], fields[3])
        if ',' not in barcodes:
            print template(barcodes)
        else:
            barcodes = barcodes.split(',')
            barcodes = list(set(barcodes))
            if len(barcodes) == 1:
                print template(barcodes[0])
            else:
                barcodes = demultiplex(barcodes, threshold)
                for barcode in barcodes:
                    print template(barcode)
    return 0


def main():
    args = get_opt()
    filename = args.infile
    threshold = args.threshold
    if filename != '-' and filename != '/dev/stdin':
        file_handle = open(filename, 'r')
    else:
        file_handle = sys.stdin
    file_processing(file_handle, threshold)
    return 0


if __name__ == '__main__':
    main()
