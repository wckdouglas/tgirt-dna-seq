#!/usr/bin/env python

import numpy as np
from scipy.spatial.distance import hamming
import fileinput
from itertools import combinations
import pandas as pd
from functools import partial
from collections import defaultdict
from networkx import Graph, connected_components
import sys
import argparse


def get_opt():
    help_message = 'Demultiplexing UMI bed file with the follwing columns:\n'+\
            '1. chrom name\n2. start\n3. end\n4. strand\n5. collapsed barcodes delim by ","\n'+\
            'This file can be generated by the command: \n'+\
            '   bedtools merge -i $BED_FILE -s -c $I -o collapse -delim ","  \n'+\
            'with barcode at column $I of a $BED_FILE \n'+\
            'The program internally used hamming distance matrix of the '+\
            'barcodes to generate connected network and cluster them'
    parser = argparse.ArgumentParser(description=help_message)
    parser.add_argument('-i','--infile',
                        help ='input bedfile, can be "-" or "/dev/stdin" for stdin (default: -)',
                        default = '-')
    parser.add_argument('-t','--threshold',
                        help='How many error between barcodes can be tolerated? (default = 1)',
                        type=int, default = 1)
    args = parser.parse_args()
    return args


def hamming_barcode(a, b):
    assert len(a) == len(b), 'Wrong barcode extraction'
    return hamming(list(a), list(b)) * len(a)


def make_graph(df):
    G = Graph()
    for i in range(len(df)):
        d = df.iloc[i,:]
        if d.distance == 0:
            G.add_edge(d.a,d.b)
        else:
            G.add_node(d.a)
            G.add_node(d.b)
    return G


def unique_barcode_from_graph(graph):
    unique_barcode = []
    for subgraph in connected_components(graph):
        subgraph = list(subgraph)
        subgraph_size = len(subgraph)
        if subgraph_size == 1:
            unique_barcode.append(subgraph[0])
        else:
            barcode = subgraph[0] + '_' + str(subgraph_size) + '_members'
            unique_barcode.append(barcode)
    return unique_barcode

def demultiplex(barcodes, threshold):
    comparison = combinations(set(barcodes),r=2)
    df = pd.DataFrame(list(comparison), columns = ['a','b']) \
        .assign(distance = lambda d: map(hamming_barcode, d.a, d.b )) \
        .assign(distance = lambda d: map(lambda x: 0 if x <= threshold else 1, d.distance ))
    graph = make_graph(df)
    unique_barcode =  unique_barcode_from_graph(graph)
    #print 'In: %i, out: %i' %(len(barcodes), len(unique_barcode))
    return unique_barcode


def make_line(chrom, start, end, strand, barcode):
    length = long(end) - long(start)
    template = '{chrom}\t{start}\t{end}\t{barcode}\t{length}\t{strand}' \
                .format(chrom = chrom,
                        start = start,
                        end = end,
                        barcode = barcode,
                        length = length,
                        strand= strand)
    return template


def file_processing(file_handle, threshold):
    for line in file_handle:
        line = line.rstrip('\n')
        fields = line.split('\t')
        barcodes = fields[-1]
        template = partial(make_line, fields[0], fields[1], fields[2], fields[3])
        if ',' not in barcodes:
            print template(barcodes)
        else:
            barcodes = barcodes.split(',')
            barcodes = list(set(barcodes))
            if len(barcodes) == 1:
                print template(barcodes[0])
            else:
                barcodes = demultiplex(barcodes, threshold)
                for barcode in barcodes:
                    print template(barcode)
    return 0


def main():
    args = get_opt()
    filename = args.infile
    threshold = args.threshold
    if filename != '-' and filename != '/dev/stdin':
        file_handle = open(filename, 'r')
    else:
        file_handle = sys.stdin
    file_processing(file_handle, threshold)
    return 0


if __name__ == '__main__':
    main()
